1、添加了 PeacockHash
2、添加了 dleftHash


input:
output:
parameters:


表长：times倍，定义成宏-- HT_SIZE_TIMES
loading factor：#full buckets / #all buckets。 定义为 loadfactor


统一：
	bool initialFromFile(char *InputFileName);
	bool insert(char *key , int val);
	bool search(char *key, int & val);  //search for a key, but return its value in the hash table
	bool remove(char *key); //remove a key from hash table
	void report(char *file); 
	bool reset();
	bool test(char *file);


	cuckoo hashing
	Rectangle Hashing
	experiments

Bloom filters:
	m, n, k.
	m: size of BF: bits.
	n: # of elements
	k: # of hash functions.
	k=ln2 m/n， false postives rate  = 0.5^k，做实验的时候，可以取k=10，false positive rate: 1/1024
	一般情况k取4~10

伪代码
构造：
1、生成等差hash table, 只能是偶数个，最多是16。链表在最后一级
2、生成 multibit bloom filter，最多是八组
3、生成 post bloom filter，对应下面的部分，长度是下面的hash table 的总和
4、生成bitmap，对每一个hashtab生成一个对应长度的bitmap
initialfromfile:
step1：
按照优先级从前向后选择hash table进行插入
	如果有空位
		插入
		mask对应bitmap
	
	否则没有空位
		插在最后一级的链表中
step2:
	对最后一级中有冲突的元素
		计算其他 hash table中的位置
		查对应的bitmap
			如果bitmap是nonmask
				将其插入对应的位置
				bitmap置一
				删除其在链上的node
			否则
				donothing
	
	insert items into bloom filter			

search:
	先查bloom filter
		确定需要查的hash table 的index
		查对应的hash table
			horz={0，1，1}
			ver = 1 or 0
			for 1 in horz
				if ver 1
					search post part of horz index
					search forward part horz index
				else
					search forward part horz index		
		如果找到
			返回
		没有找到
			return false;
			 

```````````````````````````````````````````````````````````````````````````````
2015、7、17
1、将PeacockHash 中的subhash 从指针数组改成数组
2、将dlefthash 中的subhash 从指针数组改成数组
3、添加统计访存的变量和reset函数
4、添加测试函数 test

```````````````````````````````````````````````````````````````````````````````
2015、07、18
1、添加 RTBHASH

```````````````````````````````````````````````````````````````````````````````
2015、07、19
1、添加 RTBHASH		

```````````````````````````````````````````````````````````````````````````````
2015、07、20
1、构造函数改成 最后一项大小，comdiff, stage
2、如果有多个位置可选，插入到装载因子最小的 stage中
3、hash function 个数改为 16
4、平均访存改为 float 类型
5、第一次插入时，选择最小负载因子的插入

```````````````````````````````````````````````````````````````````````````````
2015、07、22
1、修复了bug，主要是delete 那一块引起的
2、寻找KICK POSITION时，从第一个开始寻找，而不是从下一个位置开始
3、初始化时，添加了pEND，即指向链表尾节点的指针（如果链表为空，则其为 指向bucket 位置的指针）
4、当一个元素被BLIND_KICK时，其Iskicked 变为true
当超过BLIND_KICK_NUM次数还没有找到位置时，将extraNode插入到链表中，如果extranode的ISkicked == true，则插入链表尾，否则插入链表头。